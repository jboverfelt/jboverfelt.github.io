<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Go on Justin Overfelt</title>
    <link>https://jbo.io/tags/go/</link>
    <description>Recent content in Go on Justin Overfelt</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 17 Mar 2019 17:47:41 -0400</lastBuildDate>
    
        <atom:link href="https://jbo.io/tags/go/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Server-Sent Events</title>
      <link>https://jbo.io/posts/server-sent-events/</link>
      <pubDate>Sun, 17 Mar 2019 17:47:41 -0400</pubDate>
      
      <guid>https://jbo.io/posts/server-sent-events/</guid>
      <description>

&lt;p&gt;Often when the topic of web application notifications comes up, us web developers are quick to reach for WebSockets. There exists a wealth of information on them in the blogosphere and most importantly: on StackOverflow. However, WebSockets are too big a hammer for many of the cases in which they are most commonly used. Instead, I&amp;rsquo;d like you introduce you to &lt;a href=&#34;https://html.spec.whatwg.org/multipage/server-sent-events.html#server-sent-events&#34;&gt;Server Sent Events&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;why-use-sse&#34;&gt;Why use SSE?&lt;/h3&gt;

&lt;p&gt;Unlike WebSockets, Server-Sent Events are for one-way communication (server pushes to client). When you&amp;rsquo;re implementing live notifications, this is all you typically need. If you really need full-duplex communication between client and server (maybe you&amp;rsquo;re making a chat app), well, then stick to WebSockets.&lt;/p&gt;

&lt;p&gt;I find the main benefit of SSE to be its simplicity - it&amp;rsquo;s just HTTP(S)! When using WebSockets, the connection starts as HTTP, but an &amp;ldquo;Upgrade&amp;rdquo; request is sent and the connection is no longer plain HTTP. With SSE, you can continue to write HTTP handlers the way you always have in the language and framework of your choice. You just set some headers, and then write data to the client as you normally would (well, in a simple text format I&amp;rsquo;ll detail below&amp;hellip;). This means you don&amp;rsquo;t have to change anything about your web proxy or any other part of your stack. Feel free to continue to use the same authentication you use for all your other HTTP handlers. Sysadmins love it!&lt;/p&gt;

&lt;p&gt;Furthermore, the JavaScript interface for working with Server-Sent Events handles automatic reconnects! The reconnect time is even configurable. With all that said, let&amp;rsquo;s move onto the SSE protocol.&lt;/p&gt;

&lt;h3 id=&#34;the-sse-protocol&#34;&gt;The SSE Protocol&lt;/h3&gt;

&lt;p&gt;The SSE protocol is text-based, and has mercifully few concepts to learn. If all you want to do is send a line of text to the client, this is the format:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;data: something happened!\n\n
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The second newline means &amp;ldquo;send the message&amp;rdquo;. The first newline is there in case you want to send messages that span more than one line. This is useful for sending JSON:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;data: {\n
data: &amp;quot;foo&amp;quot;: &amp;quot;bar&amp;quot;\n
data: }\n\n
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, it may be the case that you want to have different kinds of messages in the same &amp;ldquo;pipe&amp;rdquo;. Maybe a table is being updated by others and rows can be added or removed. You want to notify the user of both kinds of changes. Well, SSE has you covered there too with the &amp;ldquo;event&amp;rdquo; tag:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;event: add\n
data: added one\n\n

event: delete\n
data: deleted one\n\n
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, you can give events ids with the &amp;ldquo;id&amp;rdquo; tag:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;id: 1\n
data: i&#39;m one!\n\n
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s past time to give the people what they want: code samples! All server-side code in this post will be in &lt;a href=&#34;https://golang.org&#34;&gt;Go&lt;/a&gt;, but it should translate to the language of your choice easily.&lt;/p&gt;

&lt;h3 id=&#34;the-backend&#34;&gt;The Backend&lt;/h3&gt;

&lt;p&gt;The implementation of a full SSE server is out of the scope of this blog post (which is already too long), if you&amp;rsquo;d like something more in-depth for Go, I heartily recommend &lt;a href=&#34;https://thoughtbot.com/blog/writing-a-server-sent-events-server-in-go&#34;&gt;this&lt;/a&gt; post from ThoughtBot.&lt;/p&gt;

&lt;p&gt;Instead, we&amp;rsquo;ll cover the basics of writing an HTTP handler to do Server-Sent Events in Go. As is customary for lazy bloggers like myself, I&amp;rsquo;ve elided error handling. Furthermore, the code assumes you have a some sort of broker which hands out channels (little typesafe queues that Go provides) for clients to read from. This broker also allows ID generation and registering/deregistering clients. Don&amp;rsquo;t get bogged down here, just think &amp;ldquo;this broker returns things that we can read messages from&amp;rdquo;. More information on doing this is in the ThoughtBot blog post referenced earlier. I haven&amp;rsquo;t included that here because it will be heavily dependent on your use case.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#008000;font-weight:bold&#34;&gt;package&lt;/span&gt; main

&lt;span style=&#34;color:#008000;font-weight:bold&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#00f&#34;&gt;main&lt;/span&gt;() {
	&lt;span style=&#34;color:#408080;font-style:italic&#34;&gt;// set up the fictional broker
&lt;/span&gt;&lt;span style=&#34;color:#408080;font-style:italic&#34;&gt;&lt;/span&gt;	broker &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;Broker{}
	http.&lt;span style=&#34;color:#00f&#34;&gt;HandleFunc&lt;/span&gt;(&lt;span style=&#34;color:#00f&#34;&gt;eventHandler&lt;/span&gt;(broker))

	http.&lt;span style=&#34;color:#00f&#34;&gt;ListenAndServe&lt;/span&gt;(&lt;span style=&#34;color:#ba2121&#34;&gt;&amp;#34;:3131&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#008000;font-weight:bold&#34;&gt;nil&lt;/span&gt;)
}

&lt;span style=&#34;color:#008000;font-weight:bold&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#00f&#34;&gt;eventHandler&lt;/span&gt;(broker &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;Broker) http.HandlerFunc {
	&lt;span style=&#34;color:#008000;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#008000;font-weight:bold&#34;&gt;func&lt;/span&gt;(w http.ResponseWriter, r &lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;http.Request) {
		id &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt; broker.&lt;span style=&#34;color:#00f&#34;&gt;GenerateID&lt;/span&gt;()
		msgChan &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt; broker.&lt;span style=&#34;color:#00f&#34;&gt;RegisterNewClient&lt;/span&gt;(id)

		w.&lt;span style=&#34;color:#00f&#34;&gt;Header&lt;/span&gt;().&lt;span style=&#34;color:#00f&#34;&gt;Set&lt;/span&gt;(&lt;span style=&#34;color:#ba2121&#34;&gt;&amp;#34;Content-Type&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#ba2121&#34;&gt;&amp;#34;text/event-stream&amp;#34;&lt;/span&gt;)
		w.&lt;span style=&#34;color:#00f&#34;&gt;Header&lt;/span&gt;().&lt;span style=&#34;color:#00f&#34;&gt;Set&lt;/span&gt;(&lt;span style=&#34;color:#ba2121&#34;&gt;&amp;#34;Cache-Control&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#ba2121&#34;&gt;&amp;#34;no-cache&amp;#34;&lt;/span&gt;)
		w.&lt;span style=&#34;color:#00f&#34;&gt;Header&lt;/span&gt;().&lt;span style=&#34;color:#00f&#34;&gt;Set&lt;/span&gt;(&lt;span style=&#34;color:#ba2121&#34;&gt;&amp;#34;Connection&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#ba2121&#34;&gt;&amp;#34;keep-alive&amp;#34;&lt;/span&gt;)

		&lt;span style=&#34;color:#408080;font-style:italic&#34;&gt;// in real code, check to make sure this cast works!
&lt;/span&gt;&lt;span style=&#34;color:#408080;font-style:italic&#34;&gt;&lt;/span&gt;		flusher, _ &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt; w.(http.Flusher)

		&lt;span style=&#34;color:#008000;font-weight:bold&#34;&gt;for&lt;/span&gt; {
			&lt;span style=&#34;color:#008000;font-weight:bold&#34;&gt;select&lt;/span&gt; {
			&lt;span style=&#34;color:#008000;font-weight:bold&#34;&gt;case&lt;/span&gt; msg &lt;span style=&#34;color:#666&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;&amp;lt;-&lt;/span&gt;msgChan:
				fmt.&lt;span style=&#34;color:#00f&#34;&gt;Fprintf&lt;/span&gt;(w, &lt;span style=&#34;color:#ba2121&#34;&gt;&amp;#34;data: %s\n\n&amp;#34;&lt;/span&gt;, msg)
				flusher.&lt;span style=&#34;color:#00f&#34;&gt;Flush&lt;/span&gt;()
			&lt;span style=&#34;color:#008000;font-weight:bold&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;&amp;lt;-&lt;/span&gt;r.&lt;span style=&#34;color:#00f&#34;&gt;Context&lt;/span&gt;().&lt;span style=&#34;color:#00f&#34;&gt;Done&lt;/span&gt;():
				broker.&lt;span style=&#34;color:#00f&#34;&gt;DeregisterClient&lt;/span&gt;(id)
				&lt;span style=&#34;color:#008000;font-weight:bold&#34;&gt;return&lt;/span&gt;
			}
		}
	}
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Ok, there are some things to unpack here. I don&amp;rsquo;t want to talk too much about the Go-specific parts, because this is an SSE tutorial. Here are the important bits:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The setting of the headers, specifically the Content-Type header. This &lt;strong&gt;must&lt;/strong&gt; be set to &lt;code&gt;text/event-stream&lt;/code&gt;. The other headers are for ensuring that the browser doesn&amp;rsquo;t cache messages and telling it that this connection will be long-lived.&lt;/li&gt;
&lt;li&gt;Writing data out to the client with &lt;code&gt;Fprintf&lt;/code&gt;. We&amp;rsquo;re using the aforementioned format here with the &lt;code&gt;data:&lt;/code&gt; tag.&lt;/li&gt;
&lt;li&gt;The &amp;ldquo;infinite&amp;rdquo; for loop, which writes data to the client until the user navigates away from the page.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I claim that this is conceptually straightfoward when compared to WebSockets and allows nearly endless tailoring to fit the needs of your application. To summarize: set the right headers, and write data out in the SSE format until the user leaves or otherwise says they don&amp;rsquo;t want updates anymore.&lt;/p&gt;

&lt;h3 id=&#34;the-frontend&#34;&gt;The Frontend&lt;/h3&gt;

&lt;p&gt;The &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/EventSource&#34;&gt;EventSource&lt;/a&gt; interface is all you need!&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;color:#008000;font-weight:bold&#34;&gt;var&lt;/span&gt; client &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#008000;font-weight:bold&#34;&gt;new&lt;/span&gt; EventSource(&lt;span style=&#34;color:#ba2121&#34;&gt;&amp;#34;https://mysite.local:3131&amp;#34;&lt;/span&gt;)
client.onmessage &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; (e) =&amp;gt; { console.log(e.data) }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;onerror&lt;/code&gt; and &lt;code&gt;onopen&lt;/code&gt; handlers are also available for handling errors and performing tasks when the connection is opened.&lt;/p&gt;

&lt;p&gt;You might do any number of things in the &lt;code&gt;onmessage&lt;/code&gt; handler, perhaps rendering a new row in a table, or adding the line of data you just received to an array and having Vue/React/etc rerender your component!&lt;/p&gt;

&lt;p&gt;If you broke up your events by type like I mentioned earlier, you can set up your handlers like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;client.addEventListener(&lt;span style=&#34;color:#ba2121&#34;&gt;&amp;#39;add&amp;#39;&lt;/span&gt;, (e) =&amp;gt; { console.log(e.data) }, &lt;span style=&#34;color:#008000;font-weight:bold&#34;&gt;false&lt;/span&gt;)
client.addEventListener(&lt;span style=&#34;color:#ba2121&#34;&gt;&amp;#39;delete&amp;#39;&lt;/span&gt;, (e) =&amp;gt; { console.log(e.data) }, &lt;span style=&#34;color:#008000;font-weight:bold&#34;&gt;false&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;thanks&#34;&gt;Thanks!&lt;/h3&gt;

&lt;p&gt;I hope you&amp;rsquo;ve enjoyed this post. Hit me up on &lt;a href=&#34;https://mastodon.sdf.org/@jboverf&#34;&gt;Mastodon&lt;/a&gt;, especially if I did something wrong!&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>